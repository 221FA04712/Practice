//Recursive Implementation of atoi()(leetcode 8)


class Solution {
    public int myAtoi(String s) {
        s = s.strip();  
        if (s.isEmpty()) return 0;

        int i = 0;
        int sign = 1;

     
        if (s.charAt(i) == '-') {
            sign = -1;
            i++;
        } else if (s.charAt(i) == '+') {
            i++;
        }

        
        return helper(s, i, 0, sign);
    }

    private int helper(String s, int i, int res, int sign) {
        if (i >= s.length() || !Character.isDigit(s.charAt(i))) {
            return res * sign;
        }

        int digit = s.charAt(i) - '0';

        if (res > Integer.MAX_VALUE / 10 || 
            (res == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10)) {
            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
        }

        return helper(s, i + 1, res * 10 + digit, sign);
    }
}




//Count Good Numbers(leetcode 1922)


class Solution {

    public long MOD = 1000000007;
    
    public int countGoodNumbers(long n) {
        
        
        long odd = n/2;
        long even = (n+1)/2;
        return (int)(pow(5,even) * pow(4,odd) % MOD);
    }
    
    public long pow(long x, long n){
        
        if(n==0) 
            return 1;

        long temp = pow(x,n/2);
        
       
        if(n%2==0){
            return (temp * temp)% MOD;
        }
       
        else{
            return (x * temp * temp)% MOD;
        }
    }
}






//leetcode-50(pow(x,n))

class Solution {
    public double myPow(double x, int n) {
        
        if (n == 0) {
            return 1;
        }

        long N = n;
        if (N < 0) {
            N = -N;
            x = 1 / x;
        }

    
        if (N % 2 == 0) {
            return myPow(x * x, (int) (N / 2));
        } 
    
        else {
            return x * myPow(x, (int) (N - 1));
        }
    }
}
